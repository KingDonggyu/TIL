# 서버 컴포넌트 사용 이유와 방법

> [React 서버 컴포넌트를 사용해야 하는 이유와 방법](https://www.freecodecamp.org/korean/news/how-to-use-react-server-components/)을 읽으며

2020년 말, 리액트 팀은 "제로-번들-사이즈 리액트 서버 컴포넌트" 개념을 도입했다.

### 클라이언트 사이드 UI 라이브러리로서의 리액트

- 리액트는 처음부터 클라이언트 사이드 UI 라이브러리였다.

  웹 및 모바일 개발자가 컴포넌트 기반 아키텍처를 활용하여 애플리케이션을 개발하는 데 도움이 되는 자바스크립트 기반의 오픈 소스 라이브러리다.

- 리액트 철학은 우리가 디자인 전체를 더 작고 독립적인 부분인 컴포넌트라고 불리는 작은 조각으로 나누는 것을 제안한다.

  - 하나의 컴포넌트가 여러 개의 하위 컴포넌트로 분해되고, state라고 불리는 데이터와 서로 다른 컴포넌트 간에 데이터를 전달하는 방법인 props를 가질 수 있다.

  - 컴포넌트들을 계층 구조로 나누고, 상태를 정의하고, 상태를 변경하여 발생되는 효과(effect)를 관리하고, 데이터 흐름을 결정한다.

- 이 글에서는 이러한 전통적인 컴포넌트를 **클라이언트 컴포넌트**라고 부르겠다.

---

### 리액트 앱의 일반적인 문제

**1. 레이아웃 이동 문제**

- 매우 흔한 UX 문제 중 하나는 컴포넌트가 렌더링될 때 레이아웃이 갑자기 이동되는 현상이다.

- 아래 JSX의 `CourseList` 와 `Testimonials` 두 컴포넌트 모두 데이터를 가져오기 위해 네트워크 호출(API 호출)을 수행한다고 가정해 보자.

  ```html
  <CourseWraper>
    <CourseList />
    <Testimonials />
  </CourseWraper>
  ```

- 이러한 컴포넌트들이 네트워크 호출을 수행하는 경우, 응답이 돌아오는 순서에 대한 보장이 없다.

- `Testimonials` 컴포넌트의 네트워크 호출이 CourseList 컴포넌트보다 먼저 완료되는 상황에서, `Testimonials` 컴포넌트가 먼저 렌더링되고 그 다음에 `CourseList` 컴포넌트가 렌더링된다.

  ![layoutshift-1](https://github.com/KingDonggyu/TIL/assets/33220404/625e629f-b2ab-465e-a704-06be18f56129)

- 로딩 인디케이터나 깜빡임 효과를 통해서 사용자에게 잠시 후를 기대하도록 알려주어 UX를 좀 더 향상시킬 수는 있지만, 이 잠시 후가 언제가 될지는 확신하지 못한다.

**2. 네트워크 워터폴(waterfall) 문제**

- 아래 JSX에서 `CourseList` 과 `Testimonials` 컴포넌트와 함께 이제 `CourseWrapper`도 네트워크 호출을 수행한다고 가정해 보자.

  ```html
  <CourseWraper>
    <CourseList />
    <Testimonials />
  </CourseWraper>
  ```

- 부모 컴포넌트는 데이터를 가져오기 위해 네트워크 호출을 수행하고, 그 하위 컴포넌트들 또한 네트워크 호출을 수행한다.

- 그런데 이때, 부모 컴포넌트는 네트워크 호출이 완료될 때까지 렌더링되지 않기 때문에 자식 컴포넌트들의 렌더링도 블로킹된다.

- 따라서 컴포넌트 렌더링 워터폴 문제가 발생하고 이에 따라 네트워크 워터폴 문제 또한 발생한다.

**3. 유지 보수 관련 문제**

- 단일 API 호출인 `fetchAllDetails()`를 사용하여 부모 컴포넌트를 포함한 모든 컴포넌트의 세부 정보를 한 번에 가져온다고 가정해보자.

  ```jsx
  function Course() {
    // 실제 네트워크 호출을 가정하면,
    // useEffect를 사용하여 처리할 것이다.
    const info = fetchAllDetails();

    return (
      <CourseWrapper ino={info.wrapperInfo}>
        <CourseList ino={info.listInfo} />
        <Testimonials ino={info.testimonials} />
      </CourseWrapper>
    );
  }
  ```

  - 필요한 정보를 각 컴포넌트에 props로 전달한다.

  - 이것은 위에서 본 워터폴 문제보다 더 나은 접근 방법일 것이다.

- 그러나 이것은 일부 유지 보수 문제를 야기할 수 있다.

- 어느날, `Testimonials` 기능을 삭제하기로 결정했다고 가정해 보자.

  - 위의 코드에서 `Testimonials` 컴포넌트를 간단히 삭제할 수 있다.

  - 그런데, `fetchAllDetails()` 호출을 통해 가져온 데이터를 정리하는 것을 잊을 수 있습니다. 사용되지 않고 불필요한 상태로 남아 있을 수 있다.

**4. 성능 비용**

- 리액트 컴포넌트는 클라이언트 사이드 자바스크립트 함수이다. 그래서 클라이언트에서 애플리케이션을 로드할 때, 컴포넌트가 클라이언트에 다운로드되고 리액트가 그것들을 렌더링하는데 필요한 작업을 수행한다.

- 사용자가 요청을 보낼 때, 앱은 HTML과 연결된 자바스크립트, CSS 및 이미지와 같은 다른 에셋을 다운로드한다.

  - 클라이언트 사이드(브라우저에서)에서 리액트는는 마법을 부리기 시작하고 HTML 구조를 하이드레이트(hydrate) 시킨다.

  - 즉, HTML을 구문 분석하고, 이벤트 리스너를 DOM에 연결하며 스토어에서 데이터를 가져온다.

- **클라이언트에서 많은 일이 일어나고 있다는 것이다.**

  - 아래 코드를 모두 클라이언트에서 다운로드하게 된다.

    ![image](https://github.com/KingDonggyu/TIL/assets/33220404/8196a5f8-d5d1-4f11-9919-e83a5571dee4)

---

### 리액트 서버 컴포넌트(RSCs)는 어떻게 도움을 줄까?

- 리액트 서버 컴포넌트는 서버에 있으므로 데이터를 더 빨리 가져올 수 있다.

  - 네트워크를 통해 왕복하지 않고도 파일 시스템 및 데이터 저장소와 같은 서버 인프라에 액세스할 수 있다.

  - 즉, 네트워크 호출 없이 데이터를 가져올 수 있다.

  ![image](https://github.com/KingDonggyu/TIL/assets/33220404/42a7abd8-0138-4e0c-bd7a-fcc9ecfb6454)

- 리액트 서버 컴포넌트에서는 상태 관리와 `useEffect` 훅을 사용한 이펙트 관리가 필요가 없다.

  ```jsx
  import { dbConnect } from '@/services/mongo';
  import { addCourseToDB } from './actions/add-course';
  import CourseList from './components/CourseList';

  export default async function Home() {
    // MongoDB 연결
    await dbConnect();

    // db의 모델을 이용하여 모든 course를 얻는다.
    const allCourses = await courses.find();

    // 서버 쪽에서 콘솔이 찍힌다.
    console.log({ allCourses });

    return (
      <main>
        <div>
          <CourseList allCourses={allCourses} />
        </div>
      </main>
    );
  }
  ```

---

### 리액트 서버 컴포넌트의 한계

리액트 서버 컴포넌트는 서버에 남아 있고 서버에서 렌더링되기에 아래 제약 사항들이 생긴다.

- 이벤트 핸들러나 리액트 훅을 사용할 수 없다.

- 브라우저 웹 API를 사용할 수 없다.

- 클라이언트 상호 작용과 관련된 모든 것에 대해서는, 계속 클라이언트 컴포넌트를 사용해야 한다.

---

### 클라이언트와 서버 컴포넌트를 함께 사용하는 방법

- 서버 및 클라이언트 컴포넌트의 조합으로 컴포넌트 계층 구조를 나타낼 수 있다.

- 하지만 서버 컴포넌트는 클라이언트 컴포넌트를 가져와 렌더링할 수 있지만, 클라이언트 컴포넌트는 내부에서 서버 컴포넌트를 렌더링할 수 없다.

  - 클라이언트 컴포넌트에서 서버 컴포넌트를 사용하려면 props로 전달하여 사용할 수 있다.

- 서버 컴포넌트에서 데이터 패칭 후 해당 데이터를 리액트가 허용하는 여러 방식대로 클라이언트 컴포넌트에 전달할 수 있다.

---

### 리액트 서버 컴포넌트는 서버 사이드 렌더링(SSR)과 동일하지 않나?

- 그렇지 않다. 둘 다 이름에 "서버"라는 단어가 들어가 있지만 비슷한 부분은 이 뿐이다.

- 서버 사이드 렌더링에서는,

  - 서버에서 날것의 HTML 문자열을 클라이언트로 보내고, 그런 다음 모든 클라이언트 사이드 자바스크립트가 다운로드된다.

  - 그리고 리액트는 HTML을 상호작용 가능한 리액트 컴포넌트로 변환하기 위해 하이드레이션을 수행한다.

  - 따라서 서버 사이드 렌더링에서 컴포넌트는 서버에 머무르지 않는다.

- [React 18: 리액트 서버 컴포넌트 준비하기 - 카카오페이 기술 블로그](https://tech.kakaopay.com/post/react-server-components/)에서 말하는 서버 컴포넌트와 서버 사이드 렌더링의 차이

  - 서버 컴포넌트의 코드는 클라이언트로 전달되지 않는다. 하지만 서버 사이드 렌더링의 모든 컴포넌트의 코드는 자바스크립트 번들에 포함되어 클라이언트로 전송된다.

  - 서버 컴포넌트는 페이지 레벨에 상관없이 모든 컴포넌트에서 서버에 접근 가능하다. 하지만 서버 사이드 렌더링의 경우 가장 top level의 페이지에서만 서버에 접근 가능하다.

  - 서버 컴포넌트는 HTML이 아닌 특별한 형태로 컴포넌트를 전달하기 때문에 클라이언트 상태를 유지하며 refetch 될 수 있다. 하지만 서버 사이드 렌더링의 경우 HTML로 전달되기 때문에 새로운 refetch가 필요한 경우 HTML 전체를 리렌더링 해야 하며 이로 인해 클라이언트 상태를 유지할 수 없다.

  => 서버 사이드 렌더링으로 초기 HTML 페이지를 빠르게 보여주고, 서버 컴포넌트로는 클라이언트로 전송되는 자바스크립트 번들 사이즈를 감소시키는 등 서버 컴포넌트는 서버 사이드 렌더링 대체가 아닌 보완의 수단으로 사용할 수 있다.

---

### 요약

- 리액트 서버 컴포넌트는 네트워크 왕복 없이 백엔드 접근이 가능하다.

- 리액트 서버 컴포넌트를 통해 네트워크 워터폴을 피할 수 있다.

- 리액트 서버 컴포넌트는 자동 코드 분할을 지원하며 번들 크기를 제로로 줄여 앱의 성능을 향상시킨다.

- 리액트 서버 컴포넌트는 서버 측에 있으므로 클라이언트 사이드 이벤트 핸들러 및 리액트 훅을 사용할 수 없다.

- 리액트 서버 컴포넌트는 클라이언트 컴포넌트를 가져와 렌더링할 수 있지만, 반대로는 불가능하다. 그러나 서버 컴포넌트를 클라이언트 컴포넌트에 props로 전달할 수 있다.
