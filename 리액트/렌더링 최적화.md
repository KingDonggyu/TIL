# 렌더링 최적화

### 렌더링이란?

- 브라우저에서 렌더링이란 결국 DOM 요소를 계산하고 그려내는 것을 말한다. HTML과 CSS를 통해서 만들어지고 계산된 DOM과 CSSOM은 결합되며, 위치를 계산한 후 최종적으로 브라우저에 그려진다.

- 우리는 브라우저에서 제공하는 DOM API를 JavaScript를 통해 호출하면서 브라우저에 그려진 화면을 변화시키는데, Vanila JavaScript를 이용해서 DOM에 직접 접근하고 수정하는 것(**명령형**), 그리고 이를 최적화 하는 것은 애플리케이션의 규모가 커지면 커질수록 관리하기 힘들어진다.

- 그래서 개발자들은 애플리케이션에서 보여주고 싶은 핵심 UI를 “선언”하기만 하면 실제로 DOM을 조작해서 UI를 그려내고, 변화시키는 일은 라이브러리나 프레임워크가 대신 해주는 방식을 찾게된다.(**선언형**)

- 이런 니즈에 맞춰서 여러 라이브러리, 프레임워크가 등장하게 되고 그 중에서 리액트가 현재는 가장 많이 사용되고 있다.

- 리액트는 선언형으로, 실제 렌더링 과정은 리액트에서 대신 처리해주고 개발자는 UI를 설계하는대만 집중하게 해준다. 하지만 때로는 리액트 내부에서 처리해주는 렌더링을 최적화 해야 되는 상황이 발생한다. 이러한 상황에서는 리액트 내부에서 렌더링이 언제 발생하는지, 어떤 과정을 거쳐서 이루어지는지를 이해하고 있어야 각 과정에서 렌더링을 최적화 할 수 있다.

---

### 리액트에서 리렌더링이 되는 시점

- 리액트에서 state를 사용하는 이유는 UI와 상태(state)를 연동시키기 위해서다. 그리고 데이터가 변경되었을 때 UI가 그에 맞춰서 변화하기 위해서 state를 변경시키는 방법을 제한시키고(setState), 이 함수가 호출 될 때 마다 리렌더링이 되도록 설계되었다.

- 이런 이유로 인해서 리액트에서 리렌더링이 발생하는 시점은 state가 변했을 때다.

- 특정 컴포넌트의 state가 변한다면, 해당 컴포넌트와 하위에 있는 모든 컴포넌트들은 리렌더링이 발생하게 된다.

---

### 리액트의 렌더링 과정

- state가 변화되고 최종적으로 브라우저상의 UI에 반영되기까지 각 컴포넌트에서는 크게 아래의 4단계를 거치게 된다.

  1. 기존 컴포넌트의 UI를 재사용할 지 확인한다.

  2. 함수 컴포넌트: 컴포넌트 함수를 호출한다 / Class 컴포넌트: `render` 메소드를 호출한다.

  3. 2의 결과를 통해서 새로운 VirtualDOM을 생성한다.

  4. 이전의 VirtualDOM과 새로운 VirtualDOM을 비교해서 실제 변경된 부분만 DOM에 적용한다.

- 4번의 과정을 왜 하는지, 근본적으로 VirtualDOM을 왜 사용할까?

  - 브라우저는 근본적으로 화면을 보여주기 위해서 HTML, CSS, JavaScript를 다운로드 받고 이를 처리해서 화면에 픽셀 형태로 그려내다. 이 과정을 CRP(Critical Rendering Path)라 부른다.

    > Critical Rendering Path는 기본적으로 아래의 과정을 수행한다.
    >
    > 1. HTML을 파싱해서 DOM을 만든다.
    > 2. CSS를 파싱해서 CSSOM을 만든다.
    > 3. DOM과 CSSOM을 결합해서 Render Tree를 만든다.
    > 4. Render Tree와 Viewport의 width를 통해서 각 요소들의 위치와 크기를 계산한다. = **Layout**
    > 5. 지금까지 계산된 정보를 이용해 Render Tree상의 요소들을 실제 Pixel로 그려낸다. = **Paint**
    > 6. 이후 DOM 또는 CSSOM이 수정될 때 마다 위의 과정을 반복한다.

  - CRP 과정을 최적화하는 것이 성능 상에 중요한 포인트다. 그런데 위 과정중에서 Layout, Paint 과정은 특히나 많은 계산을 필요로하는 부분이다.

  - UI를 변화하기 위해서는 많은 DOM 조작이 필요하고, 하나하나의 DOM 조작마다 CRP가 수행될 것이기에 이는 곧 브라우저에게 많은 연산을 요구하게 된다. 리액트는 이를 해결하고자 VirtualDOM이란 개념을 도입했다.

  - 리액트에서는 UI의 변화가 발생하면 변화에 필요한 DOM 조작들을 매번 바로 실제 DOM에 적용하는 것이 아니라, VirtualDOM이라는 리액트가 관리하고 있는 DOM과 유사한 객체 형태로 만들어낸다. 그리고 이전의 VirtualDOM과 새로운 VirtualDOM을 비교해서 실제로 변화가 필요한 DOM요소들을 찾아낸다. 그 다음에 한번에 해당 DOM요소들을 조작한다.

  - 이 처리를 통해서 브라우저에서 수행되는 CRP의 빈도를 줄일 수 있고 이게 VirtualDOM을 이용해서 리액트가 수행하는 최적화다. 이 부분에 대해 리액트를 사용하는 개발자 입장에서는 따로 최적화를 수행할 여지가 사라진다.

- 리액트를 사용하는 개발자가 할 수 있는 최적화는 1번과 3번이다.

  - **"1. 기존 컴포넌트의 UI를 재사용할 지 확인한다."** 의 경우에는 만약 리렌더링 될 컴포넌트의 UI가 이전의 UI와 동일하다고 판단되는 경우 새롭게 컴포넌트 함수를 호출하지 않고 이전의 결과값을 그대로 사용하도록 함으로써 최적화를 수행할 수 있다.

  - **"3. 2의 결과를 통해서 새로운 VirtualDOM을 생성한다."** 의 경우는 컴포넌트 함수가 호출되면서 만들어질 VirtualDOM의 형태를 비교적 차이가 적은 형태로 만들어지도록 하는 것이다. 예를 들어 UI를 바꾸기 위해서 `<div>` 태그를 `<span>` 태그로 변환시키는 것 보다는 `<div className="block" />` 을 `<div className="inline">` 으로 변환시키는 것이 VirtualDOM끼리 비교했을 때 차이가 적은 형태로 만들어진다.

- 이번 글에서는 **"1. 기존 컴포넌트의 UI를 재사용할 지 확인한다."** 에 해당하는 부분을 집중적으로 파악한다.

---

### React.memo

- state가 변한 컴포넌트의 경우 당연히 UI의 변화가 있을 것이기에 리렌더링을 해야 하지만, 하위 컴포넌트의 경우에는 경우에는 props가 변화하지 않았다면 해당 컴포넌트의 UI가 변화하지 않았을 수도 있다.

- 이런 경우에는 굳이 새롭게 컴포넌트 함수를 호출할 필요 없이 이전에 저장되어 있던 결과를 그대로 사용하는 것이 효율적이다.

- 하지만 UI가 실질적으로 변화되었는지 안되었는지를 매번 리액트가 렌더링 과정에서 일일이 모든 컴포넌트 트리를 순회하면서 검사하는 것은 비효율적이다.

- 따라서 리액트에서는 개발자에게 이 컴포넌트가 리렌더링이 되어야 할지 아닐지에 대한 여부를 표현할 수 있는 `React.memo` 함수를 제공하고 이를 통해 기존의 컴포넌트의 UI를 재사용할지 판단하는 방법을 채택했다.

  ```js
  const MyComponent = React.memo(function MyComponent(props) {
    /* render using props */
  });
  ```

- `React.memo`로 감싸진 컴포넌트의 경우에는 상위 컴포넌트가 리렌더링될 경우 무조건 리렌더링되는 것이 아니라, 컴포넌트 이전의 props와 다음 렌더링 때 사용될 props를 비교해서 차이가 있을 경우에만 리렌더링을 수행한다. 차이가 없다면 리렌더링을 수행하지 않고 기존의 렌더링 결과를 사용한다.

- 이때 중요하게 생각해야 할 것은 props를 비교하는 방식이다. `React.memo`는 기본적으로 props의 변화를 이전 props와 새로운 props를 각각 얕은 비교(shallow compare)를 해서 판단한다.

  > **얕은 비교(shallow compare)**: 참조 타입의 출처가 변했는지만 확인하는 것을 의미한다.

  - 만약 이 기본적인 비교 로직을 사용하지 않고 비교를 판단하는 로직을 직접 작성하고 싶을 경우를 대비해서 `React.memo`는 변화를 판단하는 함수를 인자로 받을 수 있도록 설정되어 있다.

    ```js
    function MyComponent(props) {
      /* render using props */
    }

    function areEqual(prevProps, nextProps) {
      /*
      true를 return할 경우 이전 결과를 재사용
      false를 return할 경우 리렌더링을 수행
      */
    }

    export default React.memo(MyComponent, areEqual);
    ```

---

### 불변성

- 불변성이란 값이 변하지 않는 것을 의미한다. 기본적으로 원시형 타입은 모두 불변하지만, 참조형 타입은 가변한다. 객체 안의 내용물들은 언제든지, 어떤 형태로든 변경할 수 있다.

  - 가변성은 메모리를 절약하면서 객체를 유연하게 사용할 수 있게 해주지만, 때때로 결과를 예상하기 힘들다는 단점과 객체간의 비교가 어렵다는 단점을 가지고 있다.

  - 객체의 경우에는 안의 내용물이 어떻게 바뀌었는지에 상관없이 해당 객체를 가리키는 메모리 주소는 동일하기에 실질적으로 내용이 변했는지를 판단하기는 어렵다.

  - 또한 내용물이 완벽히 일치하는 두 객체를 비교하더라도 각 객체를 가리키는 메모리 주소가 다르기에 두 객체는 동일하지 않다는 결과가 나오게 된다.

- 최근에는 과거에 비해 객체를 선언하고 저장하는데 사용할 수 있는 메모리 용량이 늘어났기에 메모리의 효율을 추구하기보다는 객체 비교의 편리함을 취하기 위해 객체를 불변하게 활용하는 방식이 최근에는 많이 사용되고 있다.

- 객체를 불변한다는 것은 말 그대로 한번 만들어진 객체를 수정하지 않는다는 뜻이다. 따라서 객체의 내용이 변해야 할 경우에는 원시형 타입과 마찬가지로 기존의 객체를 수정하지 않고 무조건 새로운 객체를 만든 후 교체하는 방식을 적용하게 된다.

  ```js
  const prev = { name: 'prev', hello: 'world' };
  const next = { ...prev, name: 'next' };

  prev === next; // false
  ```

---

### React.memo의 잘못된 활용

- `React.memo`에서 리액트는 props 객체 안의 각 property들을 `Object.is(===)` 연산자를 통해서 비교하여, 이 중 하나라도 false가 나올 경우 props가 변경되었다고 판단하고 리렌더링을 수행한다.

- 이러한 동작과 데이터 타입에 대해서 제대로 이해하지 않으면 memo를 잘못 활용하는 상황이 발생한다.

---

### 메모제이션

- 메모제이션은 특정한 값을 저장해뒀다가, 이후에 해당 값이 필요할 때 새롭게 계산해서 사용하는게 아니라 저장해둔 값을 활용하는 테크닉을 의미한다.

- 함수 컴포넌트는 근본적으로 함수입니다. 그리고 리액트는 매 렌더링마다 함수 컴포넌트를 다시 호출한다. 함수는 기본적으로 이전 호출과 새로운 호출간에 값을 공유할 수 없기 때문에, 특정한 함수 호출 내에서 만들어진 변수를 다음 함수 호출에도 사용하고 싶다면 그 값을 함수 외부의 특정한 공간에 저장해뒀다가 다음 호출 때 명시적으로 다시 꺼내와야 한다.

- 리액트에서는 함수 컴포넌트에서 값을 메모제이션할 수 있도록 API를 제공해주고 있다.

---

### useMemo

- `useMemo`는 리액트에서 값을 메모제이션할 수 있도록 해주는 Hook이다.

  ```js
  const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
  ```

- `useMemo`에서는 의존성 배열을 인자로 받아, 의존성 배열에 있는 값 중 하나라도 이전 렌더링과 비교했을 때 변경되었다면 메모된 값을 활용하는 것이 아니라 새로운 값을 다시 계산한다.

---

### useCallback

- 함수의 경우에는 `useMemo`를 사용해서 메모하게 되면 콜백함수에서 또다른 함수를 리턴하는 형태가 된다.

- 따라서 이러한 동작을 간소화한 `useCallback`이란 함수를 만들어서 제공해주고 있다.

  ```js
  const memorizedFunction = useCallback(() => console.log('Hello World'), []);
  ```

---

### 언제 메모제이션을 해야 할까?

- 개념만 보았을 때는 굉장히 효율적이고 사용하기만 하면 최적화가 이루어질 것 같은 느낌이 들기도 하다. 하지만 명확한 목적없이 무작정 메모이제이션을 사용하는 것은 오히려 비효율적이다.

- "새로운 값을 만드는 것과 어딘가에 이전의 값을 저장해두고 메모이제이션 함수를 호출하고 의존성을 비교해서 가져올지 말지 여부를 판단하는 것 중 어떤 것이 비용이 더 적게 들까?"

  - 만약 새로운 값을 만드는 과정이 복잡하다면 메모이제이션을 사용하는 것이 더 효율적일 수 있다.

  - 하지만 새로운 값을 만드는 과정이 복잡하지 않다면 메모이제이션을 사용하는 것은 오히려 비용이 더 많이 들 수도 있다. 컴퓨터 자원의 측면뿐만 아니라 메모이제이션을 쓰면서 코드의 복잡도가 올라간다는 개발적인 측면의 비용도 무시할 수 없다.

- 메모이제이션은 무조건 사용하는것이 좋은게 아니라, 필요성을 분석하고 필요하다고 판단되는 순간에만 사용해야 한다. 리액트에서 메모이제이션이 필요하다고 판단할 수 있는 요인은 아래 두가지다.

  1. 새로운 값을 만드는 연산이 복잡하다.

  2. 함수 컴포넌트의 이전 호출과, 다음 호출 간 사용하는 값의 동일성을 보장하고 싶다.

  - 1번의 경우에는 만약 10000개의 요소를 가진 배열이 있다고 생각하면 이 배열을 매번 생성하는 것 보다는 메모해서 활용하는 것이 효율적일 것이다.

  - 2번의 경우에는 함수 컴포넌트의 호출 간 값들의 동일성을 보장하기 위해서다.

    - 그렇다면 왜 동일성을 보장해야 할까? 그 이유는 바로 `React.memo`와 연동해서 사용하기 위해서다.

    - memo를 잘못 활용하면 props로 전달되는 객체의 동일성이 보장되지 않아, 실제 객체의 내용은 똑같아도 얕은 비교를 통해서 다른 객체라고 판단되어서 매번 리렌더링될 수 있다.

    - 이런 상황에서 전달되는 객체의 동일성을 보장하기 위해서 메모이제이션을 활용할 수 있는 것이다. 메모이제이션된 객체는 새롭게 만들어진 것이 아니라 이전의 객체를 그대로 활용하는 것이기에 얕은 비교에서 동일함을 보장받을 수 있다.

---

### 언제 최적화를 해야할까?

- 최적화는 개발자에게 굉장히 매혹적인 주제다. 뭔가 일반적인 기능 개발을 하는 것보다 최적화를 하는 것이 더 어려워보이고, 더 많은 지식이 필요하다고 생각되고, 아무나 할 수 없을 것 같다는 인상을 준다.

- 그러나 **최적화는 공짜가 아니다.** 최적화를 하기 위해서는 최적화를 위한 코드가 프로젝트에 추가되어야 할 수 있고, 이는 프로젝트의 복잡도를 비교적 증가시키게 된다. 그리고 최적화를 하기 위한 개발자의 시간과 노력 또한 투입되게 될 것이다.

- 따라서 최적화를 해야 하는 시기는 이 최적화가 명확히 가치를 창출해낼 수 있을 것이라고 기대되는 상황, 즉 현재의 프로젝트에 성능적인 이슈가 발생했거나, 발생할 가능성이 있고 이를 해결해야 될 필요성이 있는 상황에서 수행하는 것이다.

  - 최적화를 해야 하는 이유에 대해 동료의 공감이 필요하다.
